#############################################################################
# This file contains the gui specs for
# the dialog box that comes up when you select from the SPlusMenuBar
#   "Statistics"  "Compare Samples"  "Counts and Proportions"
#   "Proportions Parameters/Resample"
# The dialog box is named "Proportions Test"
#
# This file also contains:
#   menuPropResample  - the menu function
#   backPropResample  - the call back function
#   createMenuPropResample - add or ...
#   removeMenuPropResample - remove menu "Proportions Parameters/Resample..."
#############################################################################

# Allow either (Success & Trials) or (Success & Failure)
# Change name from e.g. "Success Variable" to "Successes"
copyProperty(Name = "resamp_Successes", OldName = "SPropXvec",
	     DialogPrompt = "&Successes:")
copyProperty(Name = "resamp_Trials", OldName = "SPropNvec",
	     DialogPrompt = "&Trials:",
	     IsRequired = F)
copyProperty(Name = "resamp_Failures", OldName = "SPropNvec",
	     DialogPrompt = "&Failures:",
	     IsRequired = F)
copyProperty(Name = "resampGroup_DataP", OldName = "SPropDataGroupP",
	     PropertyList = c(
	       "SPropDataFrameList",
	       "resamp_Successes",
	       "resamp_Failures",
	       "resamp_Trials"))

newProperty(Name = "resampPage_Prop", Type = "Page",
	    DialogPrompt = "Proportions",
	    PropertyList=c(
	      "resampGroup_DataP",
	      "SPropProportionsHypG",
	      "SPropProportionsOptionsG",
	      "SPropResultsG",
	      "SPropFSpace1"
	      ),
	    )



resampFormatArgumentList <- function(...){
  v <- c(...)
  paste("#", seq(from=0, length=length(v)), "=", v, sep="")
}

newFunctionInfo(Name = "menuPropResample",
		DialogHeader = "Proportions Test",
		CallBackFunction = "backPropResample",
                HelpCommand = 'help("function_menuPropResample")',
		PropertyList = c(
		  "resampPage_Prop",
		  "resampPage_boot",
		  "resampPage_perm"
		  ),
		ArgumentList = resampFormatArgumentList(
		  # defaults are defined by properties, comments here may be wrong
		  "SPropSaveObj",
		  "resamp_Successes",
		  "resamp_Failures",
		  "resamp_Trials",
		  "SPropPvec",
		  "SPropDataFrameList",
		  "SPropAlternative",
		  "SPropConfLevel",
		  "SPropYCorrect",
		  "SPropPrintObjP",

		  "resamp_performBoot",
		  "resamp_B1000_7",
		  "resamp_sampler7",
		  "resamp_strata7",	# ""
		  "resamp_seed7",
		  "resamp_Percentiles7",
		  "resamp_BCa7",
		  "resamp_Tilting7",
		  "resamp_tLimits7",
		  "resamp_Levels7",	# c(25, 50, 950, 975)/1000
		  "resamp_Histogram7",
		  "resamp_QQ7",
		  "resamp_PlotBoth7",
		  "resamp_SaveAs7",	# ""
		  "resamp_Additional7",	# ""

		  "resamp_performPerm",	# F
		  "resamp_B999_8",
		  "resamp_strata8",	# ""
		  "resamp_seed8",	# ""
		  "resamp_Histogram8",
		  "resamp_QQ8",
		  "resamp_PlotBoth8",
		  "resamp_SaveAs8",	# ""
		  "resamp_Additional8"	# ""
		  )
		)

rm(resampFormatArgumentList)

# 6/26/04  Added Failures (as alternative to trials)
#   
# 4/22/04.  The data input for this menu is different from other
# menus.  Instead of data itself, provide summaries,
# e.g.  (for 1, 2, and 3 samples)
# (1) no strata (boot.group)
# (1a) no "Data"
#	Success Variable = 40		c(40,50)	c(40,50,60)
#	Trials Variable  = 100		c(100, 111)	c(100,111,99)
# (1b) have "Data".  Data & variables must be names
#	Data = df	(a data frame)
#	Success Variable = a
#	Trials Variable = b
#     where a and b contain positive integers, same length, e.g.
#	a		= 40		c(40,50)	c(40,50,60)
#	b		= 100		c(100, 111)	c(100,111,99)
#
# (2) have strata.  length(x) = nStrata * number of samples
# (2a) no "Data"
#	Success Variable = c(25,15)	c(25,15,30,20)	c(25,15,30,20,35,25)
#	Trials Variable  = c(40,60)	c(55,45,60,51)	c(55,45,60,51,55,44)
#	Strata		 = c(1,2)	c(1,2,1,2)	rep(1:2,3)
# (2b) have "Data".  Data, variables, boot.group, perm.group  must be names.
# Note - no support provided for non-proportional stratified sampling.

menuPropResample <-
function(x, y, n = x+y,  # x = success, y = fail, n = total
	 p = NULL, data, alternative = "two.sided", conf.level = 0.95,
	 correct = T, print.p = T,
	 boot.perform = F,
	 boot.B = NULL,
	 boot.sampler = "",
	 boot.group = "",
	 boot.seed = NULL,
	 boot.summ.emp = T,
	 boot.summ.bca = T,
	 boot.summ.tilt = T,
	 boot.summ.tLimits = F,
	 boot.summ.probs = ".025, .05, .95, .975",
	 boot.plot.dist = F,
	 boot.plot.QQ = F,
	 boot.plot.both = T,
	 boot.save.obj = "",
	 boot.additional.args = "",

	 perm.perform = F,
	 perm.B = NULL,
	 perm.group = "",	# should be identical to boot.group
	 perm.seed = NULL,
	 perm.plot.dist = F,
	 perm.plot.QQ = F,
	 perm.plot.both = T,
	 perm.save.obj = "",
	 perm.additional.args = ""
	 )
{
  DEBUG <- (exists( ".resample.debug" ) && .resample.debug)
  if(DEBUG){
    cat( "AT BEGINNING of menu function.\n" )
    print( match.call() )
  }

  if(missing(y) && missing(n))
    stop("Must supply either number of failures or total.")
  x.lab <- deparse(substitute(x))
  y.lab <- deparse(substitute(y))
  n.lab <- deparse(substitute(n))
  p.lab <- deparse(substitute(p))
  data.name <- paste(x.lab, n.lab, sep = " / ")
  if(missing(n))
    data.name <- paste(x.lab, y.lab, sep = " : ")
  byStrata <- !missing(boot.group)
  if(!missing(data)) {
    data.lab <- deparse(substitute(data))
    x <- eval(parse(text = paste(data.lab, x.lab, sep = "$")))
    if(!missing(y))
      y <- eval(parse(text = paste(data.lab, y.lab, sep = "$")))
    if(!missing(n))
      n <- eval(parse(text = paste(data.lab, n.lab, sep = "$")))
    if(!missing(p))
      p <- eval(parse(text = paste(data.lab, p.lab, sep = "$")))
    if(byStrata)
      boot.group <- eval(parse(text = paste(data.lab,
				deparse(substitute(boot.group)), sep = "$")))
    data.name <- paste(data.name, " from data set ", data.lab, sep = "")
  }

  result <- prop.test(x, n, p, alternative, conf.level, correct)
  result$data.name <- data.name

  # Create flags, depending on whether we resample, and stratified
  doBoot <- ( !missing( boot.perform) && boot.perform )
  doPerm <- ( !missing( perm.perform) && perm.perform )

  if(print.p){
    print(result)
    if(byStrata)
      cat("\nPreceding results do not take stratification into account\n",
	  "so p-values and confidence intervals are not reliable.\n")
  }

  # Calculate Z statistics, if <= 2 samples, and no stratification
  doZ <- (length(n) <= 2 && !byStrata)
  if(!doZ && !(doBoot || doPerm))
    return(invisible(result))

  if(doZ){
    # Z-statistic, if 1 or two samples, including Wilson version
    # exact p-value and CI, if 1 sample
    if(length(n) == 1){
      if(missing(p)) p <- .5
      phat <- x/n
      z <- (phat - p) / sqrt(phat * (1-phat) / n)
      phatW <- (x+2)/(n+4)
      seW <- sqrt(phatW * (1-phatW) / (n+4))
      CIW <- switch(alternative,
		   two.sided = phatW + c(1,-1) *qnorm((1-conf.level)/2) *seW,
		   greater = c(phatW + qnorm((1-conf.level)) * seW, 1),
		   less = c(0, phatW - qnorm((1-conf.level)) * seW))
      pExact <- switch(alternative,
		      greater = 1 - pbinom(x-1, n, p),
		      less = pbinom(x, n, p),
		      two.sided = 2 * min(1 - pbinom(x-1, n, p),
			pbinom(x, n, p)))
      zResults <- list(method =
		      "Z, Wilson estimates, and exact p-value for one proportion",
		      z = z,
		      "Wilson estimate" = phatW,
		      "CI" = CIW,	# name is changed below
		      "exact p-value" = pExact)
    }
    else {				# 2 samples
      Phat <- x/n
      phat <- sum(x)/sum(n)
      PhatW <- (x+1)/(n+2)
      pdiff <- Phat[1] - Phat[2]
      pdiffW <- PhatW[1] - PhatW[2]
      z <- pdiff / sqrt(phat * (1-phat) * sum(1/n))
      seW <- sqrt(sum(PhatW * (1-PhatW) / (n+2)))
      CIW <- switch(alternative,
		   two.sided = pdiffW + qnorm((1-conf.level)/2) * c(seW,-seW),
		   greater = c(pdiffW + qnorm((1-conf.level)) * seW, 1),
		   less = c(-1, pdiffW - qnorm((1-conf.level)) * seW))

      zResults <- list(method = "Z, and Wilson estimates, for difference in proportions",
		      "difference in proportions" = pdiff,
		      z = z,
		      "Wilson estimate of difference" = pdiffW,
		      "CI" = CIW)	# name is changed below
    }
    names(zResults)[names(zResults) == "CI"] <- paste(format(100 * conf.level),
			   "percent Wilson confidence level")
    oldClass(zResults) <- "resampHtest"

    if(print.p)
      print(zResults)
  }

  if(!(doBoot || doPerm))
    return(invisible(c(list(prop.test = result),
		       if(doZ) list(z = zResults))))

  # #### Remainder is resampling

  # Set up data, to deal with stratification.
  Sample <- NULL
  if(!byStrata){			# no stratified sampling
    Group <- NULL
    K <- length(x)			# number of samples
    Y <- rep(rep(0:1,K), rbind(n-x, x))
    if(K>1)
      Sample <- rep(1:K, n)
  }
  else {
    if(length(boot.group) != length(x))
      stop("Success variable and Strata must have the same length.")
    K <- table(boot.group)
    nGroups <- length(K)			# number of strata
    if(length(unique(K)) > 1)
      stop("Must have the same number of samples in each group")
    K <- as.vector(K[1])		 # number of samples (in each stratum)
    if(notSorted(boot.group)){
      # sort everything by strata
      o <- order(boot.group)
      boot.group <- boot.group[o]
      x <- x[o]
      n <- n[o]
    }
    Y <- rep(rep(0:1,length(x)), rbind(n-x, x))
    Group <- rep(boot.group, n)
    if(K>1){
      Sample <- rep(rep(1:K, nGroups), n)
    }
  }
  pasteSampleGroup <- {		    # group variable for bootstrapping
    if(byStrata) paste(Group, Sample,
		       sep=if(is.character(Group) &&
			 any(regexpr(" ",boot.group)>0))"\001" else " ")
    else Sample
  }

  if(doPerm && K == 1){
    warning("Permutation tests are not supported for a single sample.")
    doPerm <- F
    if(!doBoot)
      return(invisible(c(list(prop.test = result),
			 if(doZ) list(z = zResults))))
  }

  # #### Set up calls for both bootstrap and permutation test
  # (even if only one is used)
  if(DEBUG) cat( "Setting up calls for resampling\n" )


  # Set up bootstrap call #
  boot.call <- call( if(K==2) "bootstrap2" else "bootstrap" )
  perm.call <- call( if(K==2) "permutationTestMeans" else "permutationTest" )
  boot.call$data <- Y
  perm.call$data <- Y

  if(!identical(substitute(boot.group), substitute(perm.group)))
    warning("The input for Strata should be the same for the bootstrap and permutation tests; I'll use the bootstrap version.")
  # Below, "boot.group" is used for both bootstrap and perm

  # Note -- boot.group and Group refer to how sampling is done.
  # Distinct from that is the group argument for some statistics below,
  # which refers to different samples of the data.
  # For multiple-sample problems, when group is supplied, need to create
  # a group argument for bootstrap which incorporates both.
  if(K == 1){
    # one sample
    ## boot _ bootstrap(Y, mean, statisticNames = "proportion",
    ##                   group=Group, ...)
    ## permutation testing is not meaningful
    boot.call$statistic <- as.name("mean")
    boot.call$statisticNames <- "proportion"
    boot.call$group <- Group
    boot.call$label <- paste("bootstrap", data.name, "proportion", sep=" : ")
  }
  else if(K == 2){
    # two samples
    ## boot _ bootstrap2(Y, mean,
    ##                    group = pasteSampleGroup
    ##			  ... (see "both" just below)
    ## perm _ permutationTestMeans(Y,
    ##                    alternative=alternative,
    ##                    group = Group (or nothing)
    ## (both) ...	  statisticNames = "proportion",
    ##                    treatment=Sample,
    boot.call$statistic <- as.name("mean")
    boot.call$statisticNames <- "proportion"
    perm.call$statisticNames <- "proportion"
    boot.call$treatment <- Sample
    perm.call$treatment <- Sample
    perm.call$alternative <- alternative
    boot.call$group <- pasteSampleGroup
    perm.call$group <- if(byStrata) Group
    boot.call$label <- paste("bootstrap", data.name, "diff. prop.", sep=" : ")
    perm.call$label <- paste("permutation", data.name, "diff. prop.", sep=" : ")
  }
  else {
    # more than two samples
    ## boot _ bootstrap(data.frame(Y, Sample), groupMeans(Y, Sample),
    ##      group = if(is.null(group)) Sample else GxS, ...)
    ## perm _ NULL # currently do not support permutation testing
    boot.call$data <- data.frame(Y, Sample)
    perm.call$data <- Y
    boot.call$statistic <- Quote(groupMeans(Y, Sample))
    boot.call$statisticNames <- paste("proportion", 1:K)
    boot.call$args.stat <- list(group=Sample)
    perm.call$statistic <- function(y, Sample, n, K, E){
      # chi-square statistic for comparing proportions
      x <- tabulate(Sample[y > 0], K)
      O <- c(x, n-x)
      sum((O-E)^2/E)
    }
    perm.call$statisticNames <- "X-square"
    p.overall <- sum(x)/sum(n)
    n.Sample <- fastRowSums(n, K)	# number in each sample
    perm.call$args.stat <- list(Sample = Sample,
			       n = n.Sample,
			       K = K,
			       E = c(n.Sample * p.overall,
				 n.Sample * (1-p.overall)))
    boot.call$group <- pasteSampleGroup
    perm.call$group <- if(byStrata) Group
    boot.call$label <- paste("bootstrap", data.name, "proportions", sep=" : ")
    perm.call$label <- paste("permutation", data.name, "X-square", sep=" : ")
    perm.call$alternative <- "greater"
    # only "greater" makes sense for a chi-square test
    # If could detect K, then could modify the menu
  }

  boot.call$B <- boot.B
  perm.call$B <- perm.B
  if(boot.B == 1000) boot.call$B <- NULL
  if(perm.B ==  999) perm.call$B <- NULL

  if(!missing( boot.sampler ))
    boot.call$sampler <- substitute( boot.sampler )
  if(identical(boot.call$sampler, as.name("samp.bootstrap")))
    boot.call$sampler <- NULL

  boot.call$seed <- boot.seed
  perm.call$seed <- perm.seed

  if(!missing(boot.additional.args))
    boot.call <- resampAddArgumentsToCall(boot.call, boot.additional.args)
  if(!missing(perm.additional.args))
    perm.call <- resampAddArgumentsToCall(perm.call, perm.additional.args)

  # If tilting, save indices, unless set explicitly
  if(boot.summ.tilt && is.null(boot.call$save.indices))
    boot.call$save.indices <- T
  # no trace for permutationTestMeans
  if(K == 2)
    perm.call$trace <- NULL


  # #### Bootstrap
  if(doBoot){
    if(DEBUG){
      cat( "boot.call:\n" )
      print(boot.call )
      cat( "PERFORMING BOOTSTRAP\n" )
    }

    # Call bootstrap
    boot.obj <- eval( boot.call )
    if(!missing( boot.save.obj ) && boot.save.obj != "" )
      assign( boot.save.obj, boot.obj, where = 1, immediate = T)

    # Call summary and plot functions
    summ.obj <- tabSummary.bootstrap(boot.obj, boot.summ.probs,
				    printSummary = T,
				    boot.summ.emp, boot.summ.bca,
				    correlations = F,
				    boot.summ.tilt, boot.summ.tLimits,
				    printCall = F,
				    printGroups = if(K == 2) T)
    tabPlot.resamp(boot.obj, boot.plot.dist, boot.plot.QQ, boot.plot.both )
  }


  # #### Permutation Test
  if(doPerm){
    if(DEBUG){
      cat( "perm.call:\n" )
      print(perm.call )
      cat( "PERFORMING PERMUTATION TEST\n" )
    }

    # Do permutation test
    perm.obj <- eval( perm.call )
    if( !missing( perm.save.obj ) && perm.save.obj != "" )
      assign( perm.save.obj, perm.obj, where = 1, immediate = T)

    cat("\n\t*** Permutation Test Results ***\n")
    print( perm.obj )

    tabPlot.resamp(perm.obj, perm.plot.dist, perm.plot.QQ, perm.plot.both,
		   # new plot if didn't do bootstrap plots
		   new = !(doBoot &&
			   (boot.plot.dist || boot.plot.QQ || boot.plot.both)))
  }

  invisible(c(list(prop.test = result),
	      if(doZ) list(z = zResults)))
}


backPropResample <- function( dfp ){
  # There is no callback function for the non-bootstrap proportions menu
  backResampBootPerm(dfp, "SPropDataFrameList")
}


createMenuPropResample <- function() {
  menu.name <- "SPlusMenuBar$Statistics$Compare Samples$Counts and Proportions"
  guiCreate( "MenuItem",
            Name = paste(menu.name,"$PropResample", sep=""),
            Type = "MenuItem",
            Action = "Function",
            MenuItemText = "&Proportions Parameters/Resample...",
            Command = "menuPropResample",
	    Overwrite = F,
            Index = "3")
  invisible()
}

removeMenuPropResample <- function()
{
  menu.item.name <- "SPlusMenuBar$Statistics$Compare Samples$Counts and Proportions$PropResample"
  if(is.element(menu.item.name, guiGetObjectNames("MenuItem")))
    guiRemove("MenuItem", Name=menu.item.name )
  invisible()
}

"Done with Prop.ssc" # for script file input
