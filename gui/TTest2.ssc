############################################################################
# This file contains the gui specs for
# the dialog box that comes up when you select from the SPlusMenuBar
#   "Statistics"  "Compare Samples"  "Two Samples" "t Test/Resample..."
# The dialog box is named "Two-sample t Test"
#
# This file also contains:
#   menuTTest2resample  - the menu function
#   backTTest2resample  - the call back function
#   createMenuTTest2resample - add or ...
#   removeMenuTTest2resample - remove menu "Two-sample t Test"
#############################################################################

newProperty(Name = "resampPage_TTest2", Type = "Page",
	    DialogPrompt = "t Test",
	    PropertyList=c(
	      "SPropDataPG",
	      "SPropTTest2TestG",
	      "resampGroup_TrimMean",
	      "SPropHTestG",
	      "SPropConfIntervalG",
	      "SPropResultsG",
	      "SPropFSpace1"
	      ),
	    )


resampFormatArgumentList <- function(...){
  v <- c(...)
  paste("#", seq(from=0, length=length(v)), "=", v, sep="")
}

newFunctionInfo(Name = "menuTTest2resample",
		DialogHeader = "Two-sample t Test",
		CallBackFunction = "backTTest2resample",
                HelpCommand = 'help("function_menuTTest2resample")',
		PropertyList = c(
		  "resampPage_TTest2",
		  "resampPage_boot",
		  "resampPage_perm"
		  ),
		ArgumentList = resampFormatArgumentList(
		  # defaults are defined by properties, comments here may be wrong
		  "SPropSaveObj",
		  "SPropDataX",
		  "SPropVariableX",
		  "SPropVariableY",
		  "SPropDataFormat",
		  "SPropMu",
		  "SPropAlternative",
		  "SPropTTest2Paired",
		  "SPropVarEqual",
		  "SPropConfLevel",
		  "SPropPrintObjP",
		  "resamp_Trim",	# In percent
	    
		  "resamp_performBoot",
		  "resamp_B1000_7",
		  "resamp_sampler7",
		  "resamp_strata7",	# ""
		  "resamp_seed7",
		  "resamp_Percentiles7",
		  "resamp_BCa7",
		  "resamp_Tilting7",
		  "resamp_tLimits7",
		  "resamp_Levels7",	# c(25, 50, 950, 975)/1000
		  "resamp_Histogram7",
		  "resamp_QQ7",
		  "resamp_PlotBoth7",
		  "resamp_SaveAs7",	# ""
		  "resamp_Additional7",	# ""

		  "resamp_performPerm",	#  F
		  "resamp_B999_8",
		  "resamp_strata8",	# ""
		  "resamp_seed8",	# ""
		  "resamp_Histogram8",
		  "resamp_QQ8",
		  "resamp_PlotBoth8",
		  "resamp_SaveAs8",	# ""
		  "resamp_Additional8"	# ""
		  ),
		PromptList = '#2="&Variable 1:", #3="V&ariable 2:"'
		)


rm(resampFormatArgumentList) 


# This is the menu function for the two-sample t test dialog
# Default values here are irrelevant - passed from FunctionInfo & properties
menuTTest2resample <-
function(data = NULL, x, y, groups.p = F, mu = 0, alternative = "two.sided",
	 t.paired = "Two-sample t",  # other option is "Paired t"
	 var.equal = T, conf.level = 0.95,
	 print.object.p = T,
	 trimPercent = 0,  # in percent

	 boot.perform = F,
	 boot.B = NULL,
	 boot.sampler = "",
	 boot.group = "",
	 boot.seed = NULL,
	 boot.summ.emp = T,
	 boot.summ.bca = T,
	 boot.summ.tilt = T,
	 boot.summ.tLimits = F,
	 boot.summ.probs = ".025, .05, .95, .975",
	 boot.plot.dist = F,
	 boot.plot.QQ = F,
	 boot.plot.both = T,
	 boot.save.obj = "",
	 boot.additional.args = "",

	 perm.perform = F,
	 perm.B = NULL,
	 perm.group = "",	# should be identical to boot.group
	 perm.seed = NULL,
	 perm.plot.dist = F,
	 perm.plot.QQ = F,
	 perm.plot.both = T,
	 perm.save.obj = "",
	 perm.additional.args = ""
	 )
{
  test <- match.call()
  xCall <- substitute( x )
  yCall <- substitute( y )
  dataCall <- substitute( data )
  xLab <- deparse(xCall)
  yLab <- deparse(yCall)
  dataLab <- deparse(dataCall)

  DEBUG <- (exists( ".resample.debug" ) && .resample.debug)
  if(DEBUG){
    cat( "AT BEGINNING of menu function.\n" )
    print( match.call() )
    cat( "x call:  " ); print( xCall )
    cat( "y call:  " ); print( yCall )
  }

  test[[1]] <- as.name("t.test") # version of t.test
  test.args <- is.element(names(test), names(t.test))
  test <- test[test.args]
  isPaired <- (t.paired == "Paired t")
  test$paired <- isPaired
  if(isPaired)
    test$var.equal <- NULL
  if(isPaired)
    test[[1]] <- as.name("saddlepoint.test") # version of t.test
  if(groups.p) {
    if(!is.null(data) && is.element(yLab, dimnames(data)[[2]]))
      groups <- data[, dimnames(data)[[2]] == yLab]
    name.groups <- yLab
    if(any(is.na(groups)))
      stop(paste("NA's not allowed in", name.groups))
    #Previously handled group as factors, x = group1 = first level
    #Now x = group1 = those matching groups[1]
    u <- unique(groups)
    if(length(u) != 2)
      stop(paste(name.groups, "must indicate two groups."))
    name.x <- paste("x:", xLab, "with",
		   name.groups, "=", as.character(u[1]), sep = " ")
    name.y <- paste("y:", xLab, "with",
		   name.groups, "=", as.character(u[2]), sep = " ")
    if(!is.null(data))
      x <- data[, dimnames(data)[[2]] == xLab]
    if((length(x) != length(groups)))
      stop("'x' and 'groups' must have the same length.")
    #    test$x _ x[!is.na(match(as.factor(groups), level.x))]
    #    test$y _ x[!is.na(match(as.factor(groups), level.y))]
    test$x <- x[groups == u[1]]
    test$y <- x[groups != u[1]]
  }
  else {
    if(is.null(data)) {
      name.x <- paste("x:", xLab)
      name.y <- paste("y:", yLab)
      test$x <- x
      test$y <- y
    }
    else {
      name.x <- paste("x:", xLab, "in", dataLab)
      name.y <- paste("y:", yLab, "in", dataLab)
      test$x <- data[, dimnames(data)[[2]] == xLab]
      test$y <- data[, dimnames(data)[[2]] == yLab]
    }
  }

  if(trimPercent == 0){
    htest.obj <- eval(test, local=F)
    htest.obj$data.name <- paste(name.x, ", and", name.y)
    if(as.logical(print.object.p)){
      print(htest.obj)
      if(!missing(boot.group))
	cat("\nPreceding results do not take stratification into account\n",
	    "so p-values and confidence intervals are not reliable.\n")
    }
  }
  else {
    Call <- Quote(mean(x=x, trim=0))
    Call$trim <- trimPercent / 100
    if(trimPercent < 0 || trimPercent > 50)
      warning("Trim percentage must be between 0 and 50%")
    Call2 <- Quote(X - Y)
    Call$x <- test$x		     # reuse the name calculated above
    Call2[[2]] <- Call
    Call$x <- test$y
    Call2[[3]] <- Call
    htest.obj <- eval(Call2, local=F)
    # Not an htest object, but convenient to use the same name.
    if(as.logical(print.object.p))
      cat(sep="", "Difference", if(length(htest.obj) > 1) "s",
	  " in ", trimPercent, "% trimmed means:  ",
	  format(htest.obj), "\n")
  }


  ###### Resampling
  doBoot <- ( !missing( boot.perform) && boot.perform )
  doPerm <- ( !missing( perm.perform) && perm.perform )
  if(!(doBoot || doPerm))
    return(invisible(htest.obj))

  if(DEBUG) cat( "PERFORMING RESAMPLING\n" )

  if(!identical(substitute(boot.group), substitute(perm.group)))
    warning("The input for Strata should be the same for the bootstrap and permutation tests; I'll use the bootstrap version.")
  # Below, "boot.group" is used for both bootstrap and perm

  parseText <- function(..., sep="")
    parse(text = paste(..., sep=sep))[[1]]

  boot.group.call <- substitute(boot.group)
  if(!is.null(data)){
    if(is.data.frame(data)){
      # This supports simple variable names, not expressions
      xCall <- parseText(dataLab, "$", xLab)
      yCall <- parseText(dataLab, "$", yLab)
      if(!missing(boot.group))
	boot.group.call <- parseText(dataLab, "$", deparse(boot.group.call))
    }
    else if(is.matrix(data)){
      xCall <- parseText(dataLab, "[,'", xLab, "']")
      yCall <- parseText(dataLab, "[,'", yLab, "']")
      if(!missing(boot.group))
	boot.group.call <- parseText(dataLab, "[,'", deparse(boot.group.call),
				    "']")
    }
    else
      stop("Data set must be a matrix or data frame")
  }

  ###### Bootstrap #####
  if( doBoot ) {
    if(DEBUG) cat( "PERFORMING BOOTSTRAP\n" )

    #
    # Set up bootstrap call
    if(isPaired) {
      # Case 1 -- paired t, call bootstrap()
      if(DEBUG) cat( "IN paired case\n" )
      boot.call <- call("bootstrap")
      if( groups.p ){
	boot.call$data <-
	  parseText(dataLab, "[", yCall, "==", u[1], ",", xLab, "] -",
		    dataLab, "[", yCall, "==", u[2], ",", xLab, "]")
	# That is not ideal when data is a matrix; gives e.g.
	# M[,"x"][M[,"g"] == "a"]-... instead of M[M[,"g"]=="a", "x"]-...
      }
      else
	boot.call$data <- parseText(deparse(xCall), "-", deparse(yCall))
      boot.call$statistic <- as.name("mean")
    }					# end of Case 1, paired
    else {
      # Case 2 -- "Two-sample t"), call bootstrap2()
      if(DEBUG) cat( "IN unpaired two-sample case\n" )
      boot.call <- call( "bootstrap2" )
      boot.call$statistic <- as.name("mean")
      if( groups.p ) {
	boot.call$data <- xCall
	boot.call$treatment <- yCall
      }
      else {
	boot.call$data <- xCall
	boot.call$data2 <- yCall
      }

      if(!is.null(data) && !groups.p)
	warning( "You supplied two variables from the same data frame.  Variables must be independent to us a 2-sample t-test." )
      # end of Case 2, unpaired
    } 

    if(trimPercent){
      boot.call$args.stat <- list(trim = trimPercent/100)
      boot.call$label <- paste(sep="", "bootstrap ",
			      trimPercent, "% trimmed mean: ",
			      as.character(deparse(boot.call$data)))
    }
    
    if(DEBUG) {
      cat( "FINISHING setting up data part of bootstrap call\n" )
      print( boot.call )
    }

    boot.call$B <- boot.B
    if(boot.B == 1000) boot.call$B <- NULL
    
    if( !missing( boot.sampler ))
      boot.call$sampler <- substitute( boot.sampler )
    if(identical(boot.call$sampler, as.name("samp.bootstrap")))
      boot.call$sampler <- NULL
    if( !missing( boot.group ))
      boot.call$group <- boot.group.call

    boot.call$seed <- boot.seed

    if(!missing(boot.additional.args))
      boot.call <- resampAddArgumentsToCall(boot.call, boot.additional.args)

    # If tilting, save indices, unless set explicitly
    if(boot.summ.tilt && is.null(boot.call$save.indices))
      boot.call$save.indices <- T

    if(DEBUG){
      cat( "boot.call:\n" )
      print(boot.call )
    }

    #
    # Call bootstrap (evaluated at top level)
    boot.obj <- eval( boot.call, local=F )
    if( !missing( boot.save.obj ) && boot.save.obj != "" )
      assign( boot.save.obj, boot.obj, where = 1, immediate = T)

    #
    # Call summary and plot functions
    tabSummary.bootstrap(boot.obj, boot.summ.probs,
			 printSummary = T,
			 boot.summ.emp, boot.summ.bca,
			 correlations = F,
			 boot.summ.tilt, boot.summ.tLimits)
    tabPlot.resamp( boot.obj, boot.plot.dist, boot.plot.QQ, boot.plot.both )

  }					# end: if( boot.perform )

  ###### Permutation Test #####
  if( doPerm) {

    if(mu != 0)
      warning("Permutation tests are for H0:  mu1 - mu2 = 0")

    #
    # Set up permutationTestMeans call
    if(trimPercent == 0){
      perm.call <- call( "permutationTestMeans" )
      # Do not need a statistic argument
    }
    else {
      perm.call <- call( "permutationTest2" )
      perm.call$statistic <- as.name("mean")
      perm.call$args.stat <- list(trim = trimPercent/100)
      perm.call$label <- paste(sep="", "permutation ",
			      trimPercent, "% trimmed mean: ",
			      deparse(xCall), "-", deparse(yCall))
    }

    if( groups.p ) {
      perm.call$data <- xCall
      perm.call$treatment <- yCall
    }
    else {
      perm.call$data <- xCall
      perm.call$data2 <- yCall
    }
    if(isPaired)
      perm.call$paired <- T
    if(DEBUG) {
      cat( "FINISHING setting up data part of permutationTestMeans call\n" )
      print( perm.call )
    }

    perm.call$B <- perm.B
    if(alternative != "two.sided")
      perm.call$alternative <- alternative

    # No sampler

    if( !missing( boot.group ))
      perm.call$group <- boot.group.call

    perm.call$seed <- perm.seed

    if(!missing(perm.additional.args))
      perm.call <- resampAddArgumentsToCall(perm.call, perm.additional.args)

    if(DEBUG){
      cat( "perm.call:\n" )
      print(perm.call )
    }
    #
    # Call permutationTest{Means or 2} (evaluated at top level)
    perm.obj <- eval( perm.call, local=F )
    if( !missing( perm.save.obj ) && perm.save.obj != "" )
      assign( perm.save.obj, perm.obj, where = 1, immediate = T)

    cat("\n\t*** Permutation Test Results ***\n")
    print( perm.obj )

    tabPlot.resamp(perm.obj, perm.plot.dist, perm.plot.QQ, perm.plot.both,
		   # new plot if didn't do bootstrap plots
		   new = !(doBoot &&
			   (boot.plot.dist || boot.plot.QQ || boot.plot.both)))
  }					# end: if( perm.perform )

  invisible(c(list(TTest = htest.obj),
	      if(doBoot) list(Bootstrap = boot.obj),
	      if(doPerm) list("PermutationTest" = perm.obj)))
}
# save resample results before printing


##################################################

# Original is backTTest2; I'll use backTTest2fix, below
backTTest2resample <- function(dfp){
  dfp <- backTTest2fix(dfp)
  dfp <- backResampBootPerm(dfp, "SPropDataX")

  # If data frame entered and has two variables, select them appropriately
  if(cbIsChange(dfp, "SPropDataX") || cbIsInitDialogMessage(dfp)){
    data.name <- cbGetCurrValue(dfp, "SPropDataX")
    variables <- cbGetColumnNames(data.name)
    if(length(variables) == 2){
      data <- eval(as.name(data.name), local = F)
      isFactor <- sapply(data, is.factor)
      if(!any(isFactor)){
	# Check if there is an integer with two levels; if so call it factor
	isInteger <- sapply(data, is.integer)
	if(sum(isInteger) == 1 &&
	   length(unique(data[,isInteger])) == 2)
	  isFactor <- isInteger
      }
      if(sum(isFactor) == 1){
	dfp <- cbSetCurrValue(dfp, "SPropVariableX", variables[!isFactor])
	dfp <- cbSetCurrValue(dfp, "SPropVariableY", variables[isFactor])
	dfp <- cbSetCurrValue(dfp, "SPropDataFormat", TRUE)
      }
      else if(sum(isFactor) == 0){
	dfp <- cbSetCurrValue(dfp, "SPropVariableX", variables[1])
	dfp <- cbSetCurrValue(dfp, "SPropVariableY", variables[2])
	dfp <- cbSetCurrValue(dfp, "SPropDataFormat", FALSE)
      }
      # This doesn't check for a numerical grouping variable
    }
  }

  dfp
}
# Removed code that disabled permutation test in paired case


backTTest2fix <- function(dfp){
  # This version fixes errors in backTTest2:
  #  * when select paired, do not set (& disable) "assume equal variances"
  #  * when variable 2 is grouping, do not disable paired
  activeprop <- cbGetActiveProp(dfp)
  if(cbIsInitDialogMessage(dfp) || cbIsRollbackMessage(dfp) || (
								cbIsUpdateMessage(dfp) && activeprop == "SPropDataX")) {
    var.names <- cbGetColumnNamesString(cbGetCurrValue(dfp, "SPropDataX"))
    dfp <- cbSetOptionList(dfp, "SPropVariableX", var.names)
    dfp <- cbSetOptionList(dfp, "SPropVariableY", var.names)
  }
  if(cbIsUpdateMessage(dfp) && activeprop == "SPropDataX") {
    dfp <- cbSetCurrValue(dfp, "SPropVariableX", "")
    dfp <- cbSetCurrValue(dfp, "SPropVariableY", "")
  }
  # If two-sample, then enable equal variances.
  if((cbIsRollbackMessage(dfp) || activeprop == "SPropTTest2Paired") && 
     cbGetCurrValue(dfp, "SPropTTest2Paired") == "Two-sample t") {
    dfp <- cbSetEnableFlag(dfp, "SPropVarEqual", T)
  }
  # If paired, then disable equal variances.
  if((cbIsRollbackMessage(dfp) || activeprop == "SPropTTest2Paired") && 
     cbGetCurrValue(dfp, "SPropTTest2Paired") == "Paired t") {
    dfp <- cbSetEnableFlag(dfp, "SPropVarEqual", F)
  }
  dfp
}


createMenuTTest2resample <- function() {
  menu.name <- "SPlusMenuBar$Statistics$Compare Samples$Two-samples"
  guiCreate( "MenuItem",
            Name = paste(menu.name,"$T-testResample", sep=""),
            Type = "MenuItem",
            Action = "Function",
            MenuItemText = "t Test/Resample...",
            Command = "menuTTest2resample",
	    Overwrite = F,
            Index = "2")
  invisible()
}

removeMenuTTest2resample <- function(){
  menu.item.name <- "SPlusMenuBar$Statistics$Compare Samples$Two-samples$T-testResample"
  if(is.element(menu.item.name, guiGetObjectNames("MenuItem")))
    guiRemove("MenuItem",Name = menu.item.name)
  invisible()
}

"Done with TTest2.ssc" # for script file input
