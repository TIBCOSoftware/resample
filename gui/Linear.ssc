#############################################################################
# This file contains the gui specs for
# the dialog box that comes up when you select from the SPlusMenuBar
#   "Statistics"  "Regression"  "Linear/Resample..."
# The dialog box is named "Linear Regression"
#
# This file also contains:
#   menuLmResample - the menu function
#   backLmResample - callback function
#   createMenuLinearResample - add or ...
#   removeMenuLinearResample - remove menu "Linear/Resample..."
#
# Differences between the bootstrap tab here, and for other canned menus:
#   * need a statistic to bootstrap (default coef)
#   * sample observations or residuals
# Also
#   * use terminology Response and Explanatory, not Dependent and Independent
#############################################################################


##################################################
#  resampPage_Linear: 	"Bootstrap"
#
# Bootstrap page.
# Largely matches "resampPage_boot" from file guiTabs.ssc
# Except need a widegroup at the top for the statistic,
# then different spacing
##################################################
newProperty(Name = "resampPage_Linear", Type = "Page",
	    DialogPrompt = "Bootstrap",
	    PropertyList = c(
	      "resampGroup_performLinear",
	      "resampGroup_OptionsLinear",
	      #	    "resamp_Space1",
	      "resampGroup_SaveBoot7",
	      "resamp_Space2",
	      "resamp_Space3",
	      #	    "resamp_Space4",
	      "resampGroup_Additional7", # double wide
	      # new column
	      "resamp_Space5",
	      "resamp_Space6",
	      "resamp_Space7",
	      "resampGroup_Plots7",
	      "resampGroup_Summary7",
	      ),
	    )


##################################################################
# resampGroup_performLinear: "Bootstrap"
#      resamp_StatisticLinear
#
#
#        "Perform Bootstrap"       "Check Box"
#        "Statistic to Estimate"   "Wide String"  "coef"
#
# similar to "resampGroup_performBoot", except add wide box for statistic
##################################################################

newProperty(Name = "resamp_StatisticLinear",
	    DefaultValue = "coef",
	    DialogControl = "Wide Combo Box",
	    DialogPrompt = "Statistic:",
	    Disable = T,
	    IsList = F,
	    OptionList = c(
	      "coef",
	      "lines",
	      "predict",
	      ),
	    UseQuotes = F,
	    )

newProperty(Name = "resampGroup_performLinear", Type = "WideGroup",
	    DialogPrompt = "Bootstrap",
	    PropertyList = c(
	      "resamp_performBoot",
	      "resamp_StatisticLinear"
	      )
	    )

##################################################
# Change terminology, from "dependendent" to "response",
##################################################
# guiModify( "Property", SavePathName = prop.file,
# 	Name = "SPropDependent",
# 	DialogPrompt = "&Response:")
# guiModify( "Property", SavePathName = prop.file,
# 	Name = "SPropIndependent",
# 	DialogPrompt = "&Explanatory:")
# commented out, because now do that in .First.lib
# Do that to work around bug, the properties couldn't be found

##################################################
# Create copy of returned object, so function can access it
##################################################
copyProperty(Name = "resamp_ReturnObject",
	     OldName = "SPropReturnObject",
	     #	UseQuotes = T,
	     )
# I need some way to pass the name of the saved lm object to the resample code.
# This seems to work, as long as "resamp_ReturnObject" is first
# in the ArgumentList.
# But it is ugly.  I'd like to use quotes.


##################################################
# FunctionInfo
# Like original "menuLm", except add bootstrap page,
# and different Function and CallBackFunction
##################################################
resampFormatArgumentList <- function(...){
  v <- c(...)
  paste("#", seq(from=0, length=length(v)), "=", v, sep="")
}
newFunctionInfo(Name = "menuLmResample",
		Function = "menuLmResample",
		DialogHeader = "Linear Regression",
		StatusString = "",
                HelpCommand = 'help("function_menuLmResample")',
		PropertyList = c(
		  "gui_lm_model",
		  "gui_lm_summ",
		  "gui_lm_plot",
		  "gui_lm_predict",
		  "resampPage_Linear",
		  "SPropPFEnableButton"),
		DefaultValueList = "#42=F", # Set tilting to F
		CallBackFunction = "backLmResample",
		ArgumentList = resampFormatArgumentList(
		  "resamp_ReturnObject",
		  "SPropReturnObject", #1 - accessible to the menu function
		  "SPropPFFormula",
		  "SPropDataFrameList",
		  "SPropWeights",
		  "SPropSubset",
		  "SPropOmitMissing",
		  "SPropPrintShort",
		  "SPropPrintLong",
		  "SPropPrintAnova",
		  "SPropPrintCor",
		  "SPropSaveResultsObject",
		  "SPropSaveFit",
		  "SPropSaveResid",
		  "SPropPlotResidVsFit",
		  "SPropPlotSqrtAbsResid",
		  "SPropPlotResponseVsFit",
		  "SPropPlotQQ",
		  "SPropPlotRFSpread",
		  "SPropPlotCooks",
		  "SPropPlotSmooths",
		  "SPropPlotRugplot",
		  "SPropPlotIdN",
		  "SPropPlotPartialResid",
		  "SPropPlotPartialFit",
		  "SPropPlotPartialRugplot",
		  "SPropPlotPartialScale",
		  "SPropPredictNewdata",
		  "SPropSavePredictObject",
		  "SPropPredictSavePred",
		  "SPropPredictSaveCI",
		  "SPropPredictSaveStdErr",
		  "SPropConfLevel",
		  "resamp_performBoot",	# F
		  "resamp_StatisticLinear", # "coef"
		  "resamp_B1000_7",	# "1000",
		  "resamp_lmsampler",
		  "resamp_sampler7",
		  "resamp_strata7",	# ""
		  "resamp_seed7",
		  "resamp_Percentiles7", # T
		  "resamp_BCa7",	# T
		  "resamp_Tilting7",	# Default set to F above
		  "resamp_tLimits7",
		  "resamp_Levels7",	# c(25, 50, 950, 975)/1000
		  "resamp_Histogram7",	# F
		  "resamp_QQ7",		# F
		  "resamp_PlotBoth7",	# T
		  "resamp_SaveAs7",	# ""
		  "resamp_Additional7"	# ""
		  )
		)


rm(resampFormatArgumentList)

menuLmResample <-
function(lm.save.object = "",
	 formula, data, weights, subset, na.omit.p = T, print.short.p = F,
	 print.long.p = T, print.anova.p = T, print.correlation.p = F,
	 save.name = NULL, save.fit.p = F, save.resid.p = F,
	 plotResidVsFit.p = F, plotSqrtAbsResid.p = F,
	 plotResponseVsFit.p = F, plotQQ.p = F, plotRFSpread.p = F,
	 plotCooks.p = F, smooths.p = F, rugplot.p = F, id.n = 3,
	 plotPartialResid.p = F, plotPartialFit.p = F,
	 rugplotPartialResid.p = F, scalePartialResid.p = T, newdata = NULL,
	 predobj.name = NULL, predict.p = F, ci.p = F, se.p = F,
	 conf.level = 0.95,
	 boot.perform = F,
	 boot.statistic = as.name( "coef" ),  # statistic
	 boot.B = NULL,
	 boot.lmsampler = "",
	 boot.sampler = "",
	 boot.group = "",
	 boot.seed = NULL,
	 boot.summ.emp = T,
	 boot.summ.bca = T,
	 boot.summ.tilt = T,
	 boot.summ.tLimits = F,
	 boot.summ.probs = ".025, .05, .95, .975",
	 boot.plot.dist = F,
	 boot.plot.QQ = F,
	 boot.plot.both = T,
	 boot.save.object = "",
	 boot.additional.args = ""
	 )
{
  DEBUG <- if(exists( ".resample.debug" )) .resample.debug else F
  if(DEBUG) print(sys.call())
  fun.call <- match.call()
  fun.call[[1]] <- as.name("lm")
  if(na.omit.p)
    fun.call$na.action <- as.name("na.exclude")
  else fun.call$na.action <- as.name("na.fail")
  fun.args <- is.element(arg.names(fun.call), arg.names("lm"))
  fun.call <- fun.call[c(T, fun.args)]
  if(DEBUG) print(fun.call)
  lmobj <- eval(fun.call)
  #
  # Call summary function:
  tabSummary.lm(lmobj, print.short.p, print.long.p, print.correlation.p,
		print.anova.p, save.name, save.fit.p, save.resid.p)
  #
  # Call plot function:
  if(any(c(plotResidVsFit.p, plotSqrtAbsResid.p, plotResponseVsFit.p, plotQQ.p,
	   plotRFSpread.p, plotCooks.p, plotPartialResid.p)))
    tabPlot.lm(lmobj, plotResidVsFit.p, plotSqrtAbsResid.p,
	       plotResponseVsFit.p, plotQQ.p, plotRFSpread.p, plotCooks.p,
	       smooths.p, rugplot.p, id.n, plotPartialResid.p,
	       plotPartialFit.p, rugplotPartialResid.p, scalePartialResid.p)
  #
  # Call predict:
  if(any(c(predict.p, ci.p, se.p)))
    tabPredict.lm(lmobj, newdata, predobj.name, predict.p, ci.p,
		  se.p, conf.level)

  if(missing(boot.perform) || !boot.perform)
    return(invisible(lmobj))

  ##################################################
  # Resampling
  if(DEBUG) {
    cat( "Beginning bootstrap work in menuLmResample.\n" )
    print( match.call() )
  }

  if(!missing(lm.save.object)){		# passed without quotes
    lm.save.object <- as.character(substitute(lm.save.object))
  }
  if(lm.save.object != "")
    assign( lm.save.object, lmobj, where = 1, immediate = T )
  if(boot.save.object != "" && boot.save.object == lm.save.object)
    stop( "The lm object and the boot object cannot have the same name" )

  #
  # Set up bootstrap call
  boot.call <- call( "bootstrap" )
  boot.call$data <- {if(lm.save.object == "") fun.call
		    else as.name( lm.save.object )
		  }
  boot.call$statistic <- substitute( boot.statistic )
  if(identical(boot.call$statistic, as.name("lines"))){
    # Plot the data now, and change the statistic to "abline".
    # This is only for simple linear regression, with an intercept.
    if(length(coef(lmobj)) != 2){
      warning("Cannot do bootstrap lines when there are multiple predictors")
      return(invisible(lmobj))
    }
    fun.callWithXY <- fun.call
    fun.callWithXY$x <- T
    fun.callWithXY$y <- T
    lmobj2 <- eval(fun.callWithXY)
    plot(lmobj2$x[,2], lmobj2$y,
         xlab = names(lmobj$coef)[2],
         ylab = as.character(formula[[2]]))
    boot.call$statistic <- as.name("abline")
    # Turn off numerical summaries and other plots
    boot.summ.emp <- boot.summ.bca <- boot.summ.tilt <- F
    boot.summ.tLimits <- boot.plot.dist <- boot.plot.QQ <- boot.plot.both <- F
  }
  if(identical(boot.call$statistic, as.name("predict"))){
    boot.call$statistic <-
      substitute(function(...) predict(..., newdata=DATA),
                 list(DATA = ifelse1(is.null(newdata) && !missing(data),
                        substitute(data),
                        substitute(newdata))))
  }

  boot.call$B <- boot.B
  if(boot.B == 1000) boot.call$B <- NULL

  if( !missing( boot.sampler ))
    boot.call$sampler <- substitute( boot.sampler )
  if(identical(boot.call$sampler, as.name("samp.bootstrap")))
    boot.call$sampler <- NULL

  if( boot.lmsampler != "observations")
    boot.call$lmsampler <- boot.lmsampler

  if( !missing( boot.group ))
    boot.call$group <- boot.group

  boot.call$seed <- boot.seed

  if(!missing(boot.additional.args))
    boot.call <- resampAddArgumentsToCall(boot.call, boot.additional.args)

  # If tilting, save indices, unless set explicitly
  if(boot.summ.tilt && is.null(boot.call$save.indices))
    boot.call$save.indices <- T
  # If tilting, add L, unless set explicitly or missing values or trimmed cor
  if(boot.summ.tilt && is.null(boot.call$L))
    boot.call$L <- "choose"

  if(DEBUG){
    cat( "boot.call:\n" )
    print(boot.call )
  }

  #
  # Call bootstrap (evaluated at top level)
  boot.obj <- eval( boot.call, local=F)
  boot.obj$defaultLabel = resampMakeLabel("bootstrap : lm",
    substitute(data), substitute(boot.statistic))

  if( boot.save.object != "" )
    assign( boot.save.object, boot.obj, where = 1, immediate = T)

  #
  # Call summary and plot functions
  summ.obj <- tabSummary.bootstrap(boot.obj, boot.summ.probs,
				  printSummary = T,
				  boot.summ.emp, boot.summ.bca,
				  correlations = F,
				  boot.summ.tilt, boot.summ.tLimits)
  tabPlot.resamp(boot.obj, boot.plot.dist, boot.plot.QQ, boot.plot.both )

  invisible(lmobj)
}

##################################################

backLmResample <- function(dfp){
  # callback function.
  # Call backLm, backResampBoot, then clean up leftovers
  dfp <- backLm(dfp)
  dfp <- backResampBoot(dfp, "SPropDataFrameList")
  # enable or disable items that are special to this menu:
  if(cbIsNewOrChange(dfp, "resamp_performBoot")){
    dfp[c("resamp_StatisticLinear", "resamp_lmsampler"), "enable"] <-
      dfp["resamp_performBoot", "value"]
  }
  # Disable BCa and tilting limits if resampling residuals
  if(cbIsChange(dfp, "resamp_lmsampler")){
    if(cbGetCurrValue(dfp, "resamp_lmsampler") == "observations")
      dfp <- cbSetEnableFlag(dfp, c("resamp_BCa7", "resamp_Tilting7"), T)
    else {
      dfp <- cbSetCurrValue(dfp, c("resamp_BCa7", "resamp_Tilting7"), F)
      dfp <- cbSetEnableFlag(dfp, c("resamp_BCa7", "resamp_Tilting7"), F)
    }
  }
  # When ready to evaluate, pass a copy of the saved object name
  if(cbIsDone(dfp)){
    dfp <- cbSetCurrValue(dfp, "resamp_ReturnObject",
			 cbGetCurrValue(dfp, "SPropReturnObject"))
  }
  dfp
}


createMenuLinearResample <- function() {
  name <- "SPlusMenuBar$Statistics$Regression"
  guiCreate( "MenuItem",
            Name = paste( name,"$LinearResample", sep=""),
            Type = "MenuItem",
            Action = "Function",
            MenuItemText = "Linear/Resample...",
            Command = "menuLmResample",
	    Overwrite = F,
            Index = "2")
  invisible()
}


removeMenuLinearResample <- function() {
  menu.item.name <- "SPlusMenuBar$Statistics$Regression$LinearResample"
  if(is.element(menu.item.name, guiGetObjectNames("MenuItem")))
    guiRemove("MenuItem",Name=menu.item.name )
  invisible()
}

"Done with Linear.ssc" # for script file input
